# Домашнее задание к занятию «2.2. ООП: Объекты и классы»

В качестве результата пришлите ссылки на ваши GitHub-проекты в личном кабинете студента на сайте [netology.ru](https://netology.ru).

**Важно**: ознакомьтесь со ссылками, представленными на главной странице [репозитория с домашними заданиями](../README.md).

**Важно**: если у вас что-то не получилось, то оформляйте Issue [по установленным правилам](../report-requirements.md).

**Важно**: нужно сделать обе задачи в **одном** репозитории.

## Как сдавать задачи

1. Создайте на вашем компьютере Gradle-проект
1. Инициализируйте в нём пустой Git-репозиторий
1. Добавьте в него готовый файл [.gitignore](../.gitignore)
1. Добавьте в этот же каталог остальные необходимые файлы
1. Сделайте необходимые коммиты
1. Создайте публичный репозиторий на GitHub и свяжите свой локальный репозиторий с удалённым
1. Сделайте пуш (удостоверьтесь, что ваш код появился на GitHub)
1. Ссылку на ваш проект отправьте в личном кабинете на сайте [netology.ru](https://netology.ru)
1. Задачи, отмеченные, как необязательные, можно не сдавать, это не повлияет на получение зачета (в этом ДЗ все задачи являются обязательными)

## Задача №1 - Посты

Наконец мы добрались до ООП и можем уже не только решать вычислительные задачи, но и моделировать целые системы.

На лекции мы разобрали упрощённый пример того, как может выглядеть пост, давайте же посмотрим на то, как он выглядит на самом деле*.

Примечание*: возьмите себе за привычку анализировать системы, с которыми вы работаете в реальной жизни, и продумывать "как бы сделали вы".

В качестве примера возьмём всё тот же VK: https://vk.com/dev/objects/post (если страница у вас по каким-то причинам недоступна, воспользуйтесь [копией](assets/post.pdf) из каталога [assets](assets)).

На что нужно обратить внимание:
1. В Kotlin мы используем `camelCase` для полей
1. Некоторые поля помечены как `integer [0, 1]`, хотя по логике, должны быть `Boolean` (у вас должны быть `Boolean`)
1. Игнорируйте поля `post_source`, `attachments`, `geo`, `copy_history` 
1. Все остальные поля должны быть перечислены

Что мы хотим получить:
1. Data класс `Post`
1. Объект `WallService`, который внутри себя хранит посты в массиве

Итого: у вас должен быть репозиторий на GitHub, в котором расположен ваш Gradle-проект (автотесты также должны храниться в репозитории).

## Задача №2 - Wall

Теперь нужно разобраться с функциональностью сервиса, отвечающего за стены пользователей: https://vk.com/dev/wall ([копия](assets/wall.pdf)).

Нас будут интересовать следующие методы:
1. Создание записи
1. Обновление записи

### Создание записи

Итак поехали, метод для создания записи должен выглядеть вот так:
```kotlin
    fun add(post: Post): Post {
        TODO()
    }
```

Как он должен работать:
1. Он должен добавлять запись в массив, но при этом назначать посту уникальный идентификатор (среди всех постов)
1. Возвращается пост уже с выставленным идентификатором

<details>
  <summary>Подсказка</summary>
  
  Возможно, вам стоит завести private property для хранения следующего уникального `id`. Пока у нас in-memory система (всё хранится в оперативной памяти) и всё работает на одной машине, этого будет достаточно. 
</details>

### Обновление записи

Метод для создания записи должен выглядеть вот так:
```kotlin
    fun update(post: Post): Boolean {
        TODO()
    }
```

Как он должен работать:
1. Он должен находить среди всех постов запись с тем же `id`, что и у `post` и обновлять все свойства, кроме `id` владельца и даты создания
1. Если пост с таким `id` не найден, то ничего не делается и возвращается `false`, в противном случае - возвращается `true`

### Документация на Array

Для работы с любыми типами вам вполне могут понадобиться методы и операторы из тех, что мы ещё не проходили (потому что в противном случае курс превратиться в чтение документации на методы).

Поэтому нам важно, чтобы вы знали, где и как в таких случаях искать информацию (и искать её нужно не на StackOverflow или статьях, а на официальном сайте).

1\. Поскольку вы знаете, что класс называется `Array`, то идёте на по адресу https://kotlinlang.org/api/latest/jvm/stdlib/alltypes/ и через Ctrl + F (либо Cmd + F в Mac) ищете `Array`:

![](pic/alltypes.png)

Кликаете для перехода

2\. На странице описания вы видите на каких платформах доступен этот тип и как можно создавать его экземпляры:

![](pic/array.png)

3\. Далее будет идти описание конструкторов, свойств и функций, вы можете выбрать интересующее вас:

![](pic/description.png)

4\. Внутри с помощью "кусочков" кода будет описано, как эту функцию использовать (включая, например, использование в виде оператора `[]`):

![](pic/usage.png)

Т.е. на самом деле, `set` - это и есть `[]`, который мы использовали в лекции.

Обратите внимание: в Kotlin (по сравнению с Java), добавлено просто огромное количество готовых функций и различных удобных способов что-то сделать минимумом кода, поэтому прежде чем писать что-то (особенно в части работы с набором элементов), обязательно в первую очередь почитайте документацию, с высокой долей вероятности уже есть готовое решение.

### Результаты

Итого, у вас должно быть:
1. У вас должен быть репозиторий на GitHub, в котором расположен ваш Gradle-проект
1. К репозиторию должен быть подключен подключен GitHub Actions
1. В истории должен быть хотя бы один коммит, ломающий сборку

## Задача №3 - Wall Tests

Куда же без автотестов? Правильно, никуда. Вам нужно написать автотесты на ваши методы:
* на `add` - всего один, который проверяет, что после добавления поста `id` стал не равным 0
* на `update` - целых два:
    - удаляем пост с существующим `id`, возвращается `true`
    - удаляем пост с несуществующим `id`, возвращается `false`

Вы можете спросить, почему именно так? Почему мы не проверяем, что `add` действительно добавил, а `update` действительно что-то меняет?

На самом деле, нам пока совсем немного не хватает знаний, чтобы достроить нашу систему до действительно тестируемой (их мы получим на следующей лекции). Пока же сделаем именно так.

По факту, речь идёт о том, что нам придётся либо дописать специальные вспомогательные методы, либо научиться работать с `nullable` значениями.

### Проблемы синглтонов

С синглтонами есть одна большая проблема (почему их и не любят) - они создаются один раз при старте приложения и в единственном экземпляре.

Тестировать такое не всегда удобно: вы либо должны сделать метод, который "вычищает" синглтон, т.е. сбрасывает массив записей, либо переделать `object` на обычный класс.

Если вы сделаете обычный класс, тогда в каждом тесте вы можете поступить следующим образом (пример для `update`):

```kotlin
class WallServiceTest {
    @Test
    fun updateExisting() {
        // создаём целевой сервис
        val service = WallService()
        // заполняем несколькими постами 
        service.add(Post(/* заполняете поля */))
        service.add(Post(/* заполняете поля */))
        service.add(Post(/* заполняете поля */))
        // создаём информацию об обновлении
        val update = Post(/* заполняете поля */)

        // выполняем целевое действие
        val result = service.update(update)

        // проверяем результат (используйте assertTrue или assertFalse)
        assertTrue(result)
    }
}
```

Итого, у вас должно быть:
1. У вас должен быть репозиторий на GitHub, в котором расположен ваш Gradle-проект
1. К репозиторию должен быть подключен GitHub Actions
1. Сборка должна быть "зелёной" (значит, ваши тесты должны проходить)
1. Необязательно: попробуйте обеспечить максимальное покрытие тестируемых функций (проанализируйте, какой код в ваших функциях не используйте и почему, по возможности, либо избавьтесь от него, либо допишите автотесты)
